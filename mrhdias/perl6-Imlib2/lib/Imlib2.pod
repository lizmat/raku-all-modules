=head1 NAME

Imlib2 - Perl 6 interface to the Imlib2 image library.

=head1 DESCRIPTION

Perl6 binding for Imlib2, a featureful and efficient image manipulation
library, which produces high quality, anti-aliased output. You will need
this library installed in order to use Image-Imlib2 (preferably a recent
version).

=head1 SYNOPSIS

	use Imlib2;

	my $im = Imlib2.new();
	# Create a new raw image.
	my $rawimage = $im.create_image(200, 200);
	exit() unless $rawimage;

	# Sets the current image Imlib2 will be using with its function calls.
	$rawimage.context_set();
	
	# Sets the color with which text, lines and rectangles are drawn when
	# being rendered onto an image.
	$im.context_set_color(
		red   => 255,
		green => 127,
		blue  => 0,
		alpha => 255);

	$im.image_draw_rectangle(
		location => (0, 0),
		size     => (200, 200),
		fill     => True);
	
	$im.image_set_format("png");
	unlink("images/test_imlib2.png") if "images/test_imlib2.png".IO ~~ :e;
	$im.save_image("images/test_imlib2.png");

	# Frees the image that is set as the current image in Imlib2's context. 
	$im.free_image();

	exit();

=head1 API REFRENCE

The perl6 API follows closely the C implementation.

=head2 Context setting/getting.

Functions to set/get values/properties to/from the current context image.

=head3 context_set_dither_mask

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my Bool $dither_mask = True;
	$im.context_set_cliprect($dither_mask);

Parameters:

	Bool $dither_mask - The dither mask flag (True or False).

Selects if, you are rendering to a mask, or producing pixmap masks from
images, if the mask is to be dithered or not. passing in True for
dither_mask means the mask pixmap will be dithered, False means it will
not be dithered.

=head3 context_get_dither_mask

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my Bool $dither_mask = $im.context_get_dither_mask();

Returns:

	Bool $dither_mask - The current dither mask flag (True or False).

Returns the current mode for dithering pixmap masks. True means
dithering is enabled and False means it is not.

=head3 context_set_anti_alias

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my Bool $anti_alias = True;
	$im.context_set_anti_alias($anti_alias);

Parameters:

	Bool $anti_alias - The anti alias flag (True or False).

Toggles "anti-aliased" scaling of images. This isn't quite correct since
it's actually super and sub pixel sampling that it turns on and off, but
anti-aliasing is used for having "smooth" edges to lines and shapes and
this means when images are scaled they will keep their smooth appearance.
Passing in True turns this on and False turns it off.

=head3 context_get_anti_alias

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my Bool $anti_alias = $im.context_get_anti_alias();

Returns:

	Bool $anti_alias - The current anti alias flag (True or False).

Returns if Imlib2 currently will smoothly scale images. True means it
will and False means it will not.

=head3 context_set_mask_alpha_threshold

Usage:
	
	use Imlib2;
	my $im = Imlib2.new();
	my Int $mask_alpha_threshold = 127;
	$im.context_set_mask_alpha_threshold($mask_alpha_threshold);

Parameters:

	Int $mask_alpha_threshold - The mask alpha threshold (values between 0 and 255).

Selects, if you are rendering to a mask, the alpha threshold above which
mask bits are set. The default mask alpha threshold is 128, meaning that
a mask bit will be set if the pixel alpha is >= 128.

=head3 context_get_mask_alpha_threshold

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my Int $mask_alpha_threshold = $im.context_get_mask_alpha_threshold();

Returns:

	Int $mask_alpha_threshold - The current mask alpha threshold.

The current mask alpha threshold.

=head3 context_set_dither

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my Bool $dither = True;
	$im.context_set_dither($dither);

Parameters:

	Bool $dither - The dithering flag (True or False).

Sets the dithering flag for rendering to a drawable or when pixmaps are
produced. This affects the color image appearance by enabling dithering.
Dithering slows down rendering but produces considerably better results.
this option has no effect foe rendering in 24 bit and up, but in 16 bit
and lower it will dither, producing smooth gradients and much better
quality images. setting dither to True enables it and False disables it.

=head3 context_get_dither

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my Bool $dither = $im.context_get_dither();

Returns:

	Bool $dither - The current dithering flag (True or False). 

Returns if image data is rendered with dithering currently. True means
yes and False means no.

=head3 context_set_blend

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my Bool $blend = true;
	$im.context_set_blend($blend);

Parameters:

	Bool $blend - The blending flag (True or False).

When rendering an image to a drawable, Imlib2 is able to blend the
image directly onto the drawable during rendering. Setting this to True
will enable this. If the image has no alpha channel this has no effect.
Setting it to False will disable this.

=head3 context_get_blend

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my Bool $blend = $im.context_get_blend();

Returns:

	Bool $blend - The current blending flag (True or False).

Returns if Imlib2 will blend images onto a drawable whilst rendering to
that drawable. True means yes and False means no.

=head3 context_set

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $color_modifier = $im.create_color_modifier();
	$color_modifier.context_set();
	$im.free_color_modifier();

Parameters:

	Imlib2::ColorModifier $color_modifier - Current color modifier.

Sets the current color modifier used for rendering pixmaps or images to
a drawable or images onto other images. Color modifiers are lookup
tables that map the values in the red, green, blue and alpha channels
to other values in the same channel when rendering, allowing for fades,
color correction etc. to be done whilst rendering. pass in NULL as the
color_modifier to disable the color modifier for rendering.

=head3 context_get_color_modifier

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $color_modifier = $im.context_get_color_modifier();

Returns:

	Imlib2::ColorModifier $color_modifier - The current color modifier.

Returns the current color modifier being used.

=over 4

=item *

IMLIB_OP_COPY performs basic alpha blending: DST = (SRC * A) + (DST * (1 - A)).

=item *

IMLIB_OP_ADD does DST = DST + (SRC * A).

=item *

IMLIB_OP_SUBTRACT does DST = DST - (SRC * A).

=item *

IMLIB_OP_RESHADE does DST = DST + (((SRC - 0.5) / 2) * A).

=back

=head3 context_set_operation

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	$im.context_set_operation(IMLIB_OP_COPY);

Parameters:

	OperationMode $operation - The current operation mode. 

When Imlib2 draws an image onto another or an image onto a drawable it
is able to do more than just blend the result on using the given alpha
channel of the image. It is also able to do saturating additive,
subtractive and a combination of the both (called reshade) rendering.
The default mode is IMLIB_OP_COPY. you can also set it to IMLIB_OP_ADD,
IMLIB_OP_SUBTRACT or IMLIB_OP_RESHADE. Use this function to set the
rendering operation.

=head3 context_get_operation

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	say "IMLIB_OP_ADD Operation mode" if $im.context_get_operation() == IMLIB_OP_ADD;

Returns:

	OperationMode $operation - The current operation mode.

Returns the current operation mode.

=head3 context_get_font

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $font = $im.context_get_font();

Returns:

	mlib2::Font $font - The current font.

Returns the current font.

=head3 context_set_direction

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	$im.context_set_direction(IMLIB_TEXT_TO_RIGHT);

Parameters:

	TextDirection $text_direction - Text direction.

Sets the direction in which to draw text in terms of simple 90 degree
orientations or an arbitrary angle. The direction can be one of
IMLIB_TEXT_TO_RIGHT, IMLIB_TEXT_TO_LEFT, IMLIB_TEXT_TO_DOWN,
IMLIB_TEXT_TO_UP or IMLIB_TEXT_TO_ANGLE.
The default is IMLIB_TEXT_TO_RIGHT. If you use IMLIB_TEXT_TO_ANGLE,
you will also have to set the angle with context_set_angle().

=head3 context_get_direction

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	say "TEXT_TO RIGHT is the current direction of the text."
		if $im.context_get_direction() == TEXT_TO_RIGHT;

Returns:

	TextDirection $text_direction - The current direction of the text.

Returns the current direction to render text in.

=head3 context_set_angle

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my Rat $angle = -45.0;
	$im.context_set_angle($angle);

Parameters:

	Rat $angle - Angle of the text strings.

Sets the angle at which text strings will be drawn if the text direction
has been set to TEXT_TO_ANGLE with context_set_direction().

=head3 context_get_angle

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my Rat $angle = $im.context_get_angle();

Returns:

	Rat $angle - The current angle of the text strings.

Returns the current angle used to render text at if the direction is
TEXT_TO_ANGLE.

=head3 context_set_color

Usage:

	use Imlib2;
	my $im = Imlib2.new();

	# Color in RGBA space
	$im.context_set_color(
		red   => 127,
		green => 255,
		blue  => 127,
		alpha => 255);

	# Another way to setup the color channels.
	# This is like html color tags ("#RRGGBBAA").
	# RR - Red, GG - Green, BB - Blue, AA - Alpha.
	my Str $hex_str_color = "#ff00ffff";
	$im.context_set_color($hex_str_color);

	# Without the alpha color channel.
	# The default value of alpha is 255.
	my Str $hex_str_color_html = "#ff00ff";
	$im.context_set_color($hex_str_color_html);

	# You can even set a color in hexadecimal value.
	my Int $hex_num_color = 0xff00ffff;
	$im.context_set_color($hex_num_color);

	# Color in HSVA space
	$im.context_set_color(
		hue        => 180,
		saturation => 50,
		value      => 75,
		alpha      => 127);

	# Color in HLSA space
	$im.context_set_color(
		hue        => 180,
		lightness  => 75,
		saturation => 50,
		alpha      => 127);

	# Color in CMYA space
	$im.context_set_color(
		cyan    => 25,
		magenta => 125,
		yellow  => 200,
		alpha   => 255);

Parameters:

	Color in RGBA space
		Int red - Red channel of the current color (0 .. 255).
		Int green - Green channel of the current color (0 .. 255).
		Int blue - Blue channel of the current color (0 .. 255).
		Int alpha - Alpha channel of the current color (0 .. 255).

		Str $hex_str_color - Hexadecimal string like html color tags
		                     (#RRGGBBAA / #RRGGBB).
		Int $hex_num_color - Hexadecimal number like html color tags
		                     (0xRRGGBBAA).

	Color in HSVA space
		Int hue - Hue channel of the current color (0 .. 360).
		Int saturation - Saturation channel of the current color (0 .. 100).
		Int value - Value channel of the current color (0 .. 100).
		Int alpha - Alpha channel of the current color (0 .. 255).

	Color in HLSA space
		Int hue - Hue channel of the current color (0 .. 360).
		Int lightness - Lightness channel of the current color (0 .. 100).
		Int saturation - Saturation channel of the current color (0 .. 100).
		Int alpha - Alpha channel of the current color (0 .. 255).

	Color in CMYA space
		Int cyan - Cyan channel of the current color (0 .. 255).
		Int magenta - Magenta channel of the current color (0 .. 255).
		Int yellow - Yellow channel of the current color (0 .. 255).
		Int alpha - Alpha channel of the current color (0 .. 255).

Sets the color with which text, lines and rectangles are drawn when
being rendered onto an image. The values ​​depend on the selected color
space.

=head3 context_get_color

Usage:

	use Imlib2;
	my $im = Imlib2.new();

	# Color in RGBA space
	$im.context_get_color(
		red   => my $red = 0,
		green => my $green = 0,
		blue  => my $blue = 0,
		alpha => my $alpha = 0
	);
	say "Red: $red";
	say "Green: $green";
	say "Blue: $blue";
	say "Alpha: $alpha";

	say "Hex: " ~ $im.get_hex_color_code($red, $green, $blue, $alpha);

	# Color in HSVA space
	$im.context_get_color(
		hue        => my $hue = 0,
		saturation => my $saturation = 0,
		value      => my $value = 0,
		alpha      => $alpha = 0);

	# Color in HLSA space
	$im.context_get_color(
		hue        => my $hue = 0,
		lightness  => my $lightness = 0,
		saturation => my $saturation = 0,
		alpha      => $alpha = 0);

	# Color in CMYA space
	$im.context_get_color(
		cyan    => $cyan = 0,
		magenta => $magenta = 0,
		yellow  => $yellow = 0,
		alpha   => $alpha = 0);

Parameters:

	Color in RGBA space
		Int red is rw - Red channel of the current color.
		Int green is rw - Green channel of the current color.
		Int blue is rw - Blue channel of the current color.
		Int alpha is rw - Alpha channel of the current color.

	Color in HSVA space
		Int hue is rw - Hue channel of the current color.
		Int saturation is rw - Saturation channel of the current color.
		Int value is rw - Value channel of the current color.
		Int alpha is rw - Alpha channel of the current color.

	Color in HLSA space
		Int hue is rw - Hue channel of the current color.
		Int ligtness is rw - Ligtness channel of the current color.
		Int saturation is rw - Saturation channel of the current color.
		Int alpha is rw - Alpha channel of the current color.

	Color in CMYA space
		Int cyan is rw - Cyan channel of the current color.
		Int magenta is rw - Magenta channel of the current color.
		Int yellow is rw - Yellow channel of the current color.
		Int alpha is rw - Alpha channel of the current color.

The current color space for rendering text, rectangles and lines.

=head3 context_get_color_range

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $color_range = $im.context_get_color_range();
	
Returns:

	Imlib2::ColorRange $color_range - The current color range.

Returns the current color range being used for gradients.

=head3 context_set

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $image = $im.create_image(100, 200);
	$image.context_set();
	... some operations ...
	$im.free_image();

Parameters:

	Imlib2::Image $image - Current image.
	
Sets the current image Imlib2 will be using with its function calls.

=head3 context_get_image

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $image = $im.context_get_image();
	
Returns:

	Imlib2::Image $image - The current image.

Returns the current context image.

=head3 context_set_cliprect

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	$im.context_set_cliprect(
		x      => 0,
		y      => 0,
		width  => 100,
		height => 100);

Parameters:

	Int x - The top left x coordinate of the rectangle. 
	Int y - The top left y coordinate of the rectangle. 
	Int width - The width of the rectangle. 
	Int height - The height of the rectangle. 

Sets the rectangle of the current context.

=head3 context_get_cliprect

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	$im.context_get_cliprect(
		x      => my $x = 0,
		y      => my $y = 0,
		width  => my $width = 0,
		height => my $height = 0);

	say "x: $x";
	say "y: $y";
	say "width: $width";
	say "height: $height";

Parameters:

	Int x is rw - The top left x coordinate of the rectangle. 
	Int y is rw - The top left y coordinate of the rectangle. 
	Int width is rw - The width of the rectangle. 
	Int height is rw - The height of the rectangle. 

The rectangle of the current context.

=head3 set_cache_size

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $bytes = 2048 * 1024;
	$im.set_cache_size($bytes);

Parameters:

	Int $bytes - Cache size.

Sets the cache size. The size is in bytes. Setting the cache size to 0
effectively flushes the cache and keeps the cache size at 0 until set
to another value. Whenever you set the cache size Imlib2 will flush as
many old images and pixmap from the cache as needed until the current
cache usage is less than or equal to the cache size.

=head3 get_cache_size

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $bytes = $im.get_cache_size();

Returns:

	Int $bytes - The current size of the image cache in bytes.

Returns the current size of the image cache in bytes. The cache is a
unified cache used for image data AND pixmaps.

=head3 set_color_usage

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $max = 256;
	$im.set_color_usage($max);

Parameters:

	Int $max - Maximum number of colors.

Sets the maximum number of colors you would like Imlib2 to allocate for
you when rendering. The default is 256. This has no effect in depths
greater than 8 bit.

=head3 get_color_usage

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $max = $im.get_color_usage();

Returns:

	Int $max - The current number of colors.

Gets the number of colors Imlib2 currently at a maximum is allowed to
allocate for rendering. The default is 256.

=head2 Loading Functions.

Functions to load existing images.

=head3 load_image

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $file = "pictures/holidays.jpeg";
	my $image = $im.load_image($file);
	$image.context_set();
	... some operations ...
	$im.free_image();
	
	# load image with returned error.
	use Imlib2;
	my $im = Imlib2.new();
	my $file = "pictures/holidays.jpeg";
	my LoadError $error_return;
	my $image = $im.load_image($file, $error_return);
	if $error_return == IMLIB_LOAD_ERROR_NONE {
		say "No error...";
		$image.context_set();
		... some operations ...
		$im.free_image();
	}

	# Another way to load an image.
	use Imlib2;
	my $im = Imlib2.new();
	my $file = "pictures/holidays.jpeg";
	my $image = $im.load_image(
		filename    => $file,
		immediately => False,
		cache       => True);
	$image.context_set();
	... some operations ...
	$im.free_image();
	
Parameters:

	Str $file - Image file.
	LoadError $error_return - The returned error.

	Str filename - Image file.
	Bool cache - If False loads the image without looking in the cache first.
	Bool immediately - If True loads an image from disk located at the
	                   path specified by file. This forces the image data
	                   to be decoded at load time too, instead of decoding
	                   being deferred until it is needed.

Returns:

	Imlib2::Image $image - An image handle.

Loads an image from disk located at the path specified by file. Please
see the section L<How Image Loading Works|http://docs.enlightenment.org/api/imlib2/html/index.html#loading>
for more detail. Returns an image handle on success or NULL on failure.

=head3 free_image

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $file = "pictures/holidays.jpeg";
	my $image = $im.load_image($file);
	$image.context_set();
	... some operations ...
	my Bool $decache = False;
	$im.free_image() if $image.context_get_image($decache);

Parameters:

	Bool $decache - If is set to True removes image from the cache.
	
Frees the image that is set as the current image in Imlib2's context.

=head3 flush_loaders

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	$im.flush_loaders();

If you want Imlib2 to forcibly flush any cached loaders it has and
re-load them from disk (this is useful if the program just installed a
new loader and does not want to wait till Imlib2 deems it an optimal
time to rescan the loaders).

=head2 Query/Modify Image Parameters.

Functions to query and modify the image parameters, ie, set and get
information about the image.

=head3 image_get_width

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $file = "pictures/holidays.jpeg";
	my $image = $im.load_image($file);
	$image.context_set();
	my Int $width = $im.image_get_width();
	say "Width size: $width pixels";
	$im.free_image();

Returns:

	Int $width - The width in pixels of the current image.

Returns the width in pixels of the current image in Imlib2's context.

=head3 image_get_height

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $file = "pictures/holidays.jpeg";
	my $image = $im.load_image($file);
	$image.context_set();
	my Int $height = $im.image_get_height();
	say "Height size: $height pixels";
	$im.free_image();

Returns:

	Int $height - The height in pixels of the current image.

Returns the height in pixels of the current image in Imlib2's context.

=head3 image_get_size

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $file = "pictures/holidays.jpeg";
	my $image = $im.load_image($file);
	$image.context_set();
	my ($width, $height) = $im.image_get_size();
	say "Width size: " ~ $width ~ " pixels";
	say "Height size: " ~ $height ~ " pixels";
	$im.free_image();

Returns:

	Int ($width, $height) - Parcel with size in pixels of the current 
	                        image (width, height).

Returns the size in pixels of the current image in Imlib2's context.

=head3 image_get_filename

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $file = "pictures/holidays.jpeg";
	my $image = $im.load_image($file);
	$image.context_set();
	my Str $filename = $im.image_get_filename();
	say "My filename is: $filename";
	$im.free_image();

Returns:

	Str $filename - The current filename.

Returns the filename for the file that is set as the current context.
The string returned is only valid as long as no operations cause the
filename of the image to change. Saving the file with a different name
would cause this. It is suggested you duplicate the string if you wish
to continue to use the string for later processing.

=head3 image_set_has_alpha

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $image = $im.create_image(100, 200);
	$image.context_set();
	my Bool $has_alpha = True;
	$im.image_set_has_alpha($has_alpha);
	... some operations ...
	$im.free_image();

Parameters:

	Bool $has_alpha - Alpha flag (True or False).

Sets the alpha flag for the current image. Set has_alpha to True to
enable the alpha channel in the current image, or False to disable it.

=head3 image_has_alpha

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $image = $im.create_image(100, 200);
	$image.context_set();
	my Bool $has_alpha = $im.image_has_alpha();
	say "Alpha status: $has_alpha";
	... some operations ...
	$im.free_image();

Returns:

	Bool $has_alpha - Current alpha channel flag (True or False).

Returns True if the current context image has an alpha channel, or
False if it does not (the alpha data space is still there and
available - just "unused").

=head3 image_set_changes_on_disk

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $image = $im.load_image("pictures/holidays.jpeg");
	$image.context_set();
	$im.image_set_changes_on_disk();
	... some operations ...
	$im.free_image();

By default Imlib2 will not check the timestamp of an image on disk and
compare it with the image in its cache - this is to minimize disk
activity when using the cache.

Call this function and it will flag the current context image as being
liable to change on disk and Imlib2 will check the timestamp of the
image file on disk and compare it with the cached image when it next
needs to use this image in the cache.

=head3 image_set_border

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $image = $im.create_image(100, 200);
	$image.context_set();

	my $structure = Imlib2::Border.new(
		left   => 10,
		right  => 10,
		top    => 10,
		bottom => 10);
	my $border = $structure.init();

	$im.image_set_border($border);
	... some operations ...
	$im.free_image();

Parameters:

	OpaquePointer $border - The border of the image.

Sets the border of the current context image to the values contained in
the Imlib2::Border structure border points to.

=head3 image_get_border

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $image = $im.create_image(100, 200);
	$image.context_set();

	my $structure = Imlib2::Border.new();
	my $border = $structure.init();

	$im.image_get_border($border);
	$structure.get($border);
	say "Left: " ~ $structure.left;
	say "Right: " ~ $structure.right;
	say "Top: " ~ $structure.top;
	say "Bottom: " ~ $structure.bottom;
	... some operations ...
	$im.free_image();

Parameters:

	OpaquePointer $border - The border of the image passed as argument.

Fills the Imlib2::Border structure to which border points to with the
values of the border of the current context image. The border is the
area at the edge of the image that does not scale with the rest of the
image when resized - the borders remain constant in size. This is
useful for scaling bevels at the edge of images differently to the
image center.

=head3 image_set_format

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $image = $im.load_image("pictures/holidays.jpeg");
	$image.context_set();
	my Str $format = "png";
	$im.image_set_format($format);
	... some operations ...
	$im.free_image();

Parameters:

	Str $format - Format of the image.

Sets the format of the current image. This is used for when you wish
to save an image in a different format that it was loaded in, or if the
image currently has no file format associated with it.

=head3 image_get_format

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $image = $im.load_image("pictures/holidays.jpeg");
	$image.context_set();
	my Str $format = $im.image_get_format();
	... some operations ...
	$im.free_image();

Returns:

	Str $format - Current image format.

Returns the current image's format.

=head3 image_set_irrelevant

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my Bool $irrelevant = True;
	$im.image_set_irrelevant(
		format => True,
		border => False,
		alpha  => True);

Parameters:

	Bool format - Irrelevant format flag (True or False).
	Bool border - Irrelevant border flag (True or False).
	Bool alpha - Irrelevant alpha flag (True or False).

Sets if the format, border or alpha channel status value of the current
image (i.e. if there is or is not one) is irrelevant for caching
purposes - by default it is. pass irrelevant as True to make it
irrelevant and False to make it relevant for caching.

=head2 Rendering Functions.

Functions to blend multiple images.

=head3 blend_image_onto_image

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $parrot_img = $im.load_image("images/parrot.png");
	exit() unless $parrot_img;
	my $camelia_img = $im.load_image("images/camelia-logo.jpg");
	exit() unless $camelia_img;
	$parrot_img.context_set();

	$im.blend_image_onto_image(
		source       => (
			image    => $camelia_img,
			location => (0, 0),
			size     => (200, 200)
		),
		destination  => (
			location => (10, 10),
			size     => (261, 243)
		),
		merge_alpha  => True);

	$im.free_image(); # frees the parrot image
	$camelia_img.context_set();
	$im.free_image(); # frees the camelia image

Parameters:

	source - The source rectangle.
		image - The source image.
		location - X and Y coordinates of the source image.
		size - Width and height of the source image. 
	destination - The destination rectangle
		location - X and Y Int coordinates of the source image.
		size - Width and height of the destination image.
	merge_alpha - Alpha flag (True or False).

Blends the source rectangle (location => (Int $x, Int $y) and size =>
(Int $width, Int $height)) from source_image onto the current image at
the destination (location => (Int $x, Int $y)) location scaled to the
size (size => (Int $width, Int $height)) destination. If merge_alpha is
set to True it will also modify the destination image alpha channel,
otherwise the destination alpha channel is left untouched.

=head2 Creation Functions.

Functions to create, clone and resize images.

=head3 create_image

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my Int $width = 100;
	my Int $height = 200;
	my Imlib2::Image $image = $im.create_image($width, $height);

Parameters:

	Int $width - The width of the image.
	Int $height - The height of the image.

Returns:

	Imlib2::Image $image - A new raw image.

Creates a new raw image of size width and height. The contents of this
image at creation time are undefined (they could be garbage memory).
You are free to do whatever you like with this image. It is not cached.
On success an image handle is returned - on failure NULL is returned.

=head3 clone_image

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $loaded_image = $im.load_image("pictures/holidays.jpeg");
	$loaded_image.context_set();
	my Imlib2::Image $cloned_image = $im.clone_image();
	$cloned_image.context_set();
	... some operations ...
	$im.free_image(); # frees the cloned image
	$loaded_image.context_set();
	$im.free_image(); # frees the loaded image

Returns:

	Imlib2::Image $cloned_image - A valid image, otherwise NULL.

Creates an exact duplicate of the current image and returns a valid
image handle on success, or NULL on failure.

=head3 create_resized_image

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $loaded_image = $im.load_image("pictures/holidays.jpeg");

	# Crop and Scale
	$loaded_image.context_set();
	my Imlib2::Image $resized_image = $im.create_resized_image(
		location => (50, 60),
		crop     => (150, 100),
		scale    => (300, 300));
	$resized_image.context_set();
	... some operations ...
	$im.free_image(); # frees the resized image

	# Crop only
	$loaded_image.context_set();
	my Imlib2::Image $cropped_image = $im.create_resized_image(
		location => (10, 20),
		crop     => (180, 120));
	$cropped_image.context_set();
	... some operations ...
	$im.free_image(); # frees the cropped image

	# Scale only
	$loaded_image.context_set();
	my Imlib2::Image $scaled_image = $im.create_resized_image(
		scale    => (180, 120));
	$scaled_image.context_set();
	... some operations ...
	$im.free_image(); # frees the scaled image

	$loaded_image.context_set();
	$im.free_image(); # frees the loaded image

Parameters:

	location - Parcel with the top left Int $x and Int $y coordinates
	           of the source rectangle.
	crop - Parcel with Int $width and Int $height of the source rectangle.
	scale - Parcel with Int $width and Int $height of the destination image.

Returns:

	Imlib2::Image $resized_image - A valid image, otherwise NULL.

If the crop option is set creates a duplicate of a (x, y, width, height)
rectangle in the current image and returns a valid image handle on
success, or NULL on failure. If scale is set, it will scale the new image
to the new destination destination_width and destination_height whilst
cropping.

=head2 Image Modification.

Functions to modify the images.

=head3 image_flip

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $image = $im.load_image("pictures/holidays.jpeg");
	$image.context_set();
	my FlipMode $flip_mode = IMLIB_FLIP_HORIZONTAL;
	$im.image_flip($flip_mode);
	... some operations ...
	$im.free_image();

Parameters:

	FlipMode $flip_mode - The flip mode flag.

Flips/mirrors the current image.

=over 4

=item *

IMLIB_FLIP_HORIZONTAL - Flips/mirrors the current image horizontally

=item *

IMLIB_FLIP_VERTICAL - Flips/mirrors the current image vertically.

=item *

IMLIB_FLIP_DIAGONAL - Flips/mirrors the current image diagonally (good
                      for quick and dirty 90 degree rotations if used
                      before to after a horizontal or vertical flip).

=back

=head3 image_orientate

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $image = $im.load_image("pictures/holidays.jpeg");
	$image.context_set();
	my RotationMode $orientation = IMLIB_ROTATE_90_DEGREES;
	$im.image_orientate($orientation);
	... some operations ...
	$im.free_image();

Parameters:

	RotationMode $orientation - The rotation mode flag.

Performs 90 degree rotations on the current image.

=over 4

=item *

IMLIB_ROTATE_90_DEGREES - rotates clockwise by 90 degrees.

=item *

IMLIB_ROTATE_180_DEGREES - rotates clockwise by 180 degrees.

=item *

IMLIB_ROTATE_270_DEGREES - rotates clockwise by 270 degrees.

=back

=head3 image_tile

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $image = $im.load_image("pictures/holidays.jpeg");
	$image.context_set();
	my TileMode $flip_mode = IMLIB_TILE_HORIZONTAL;
	$im.image_tile($tile_mode);
	... some operations ...
	$im.free_image();

Parameters:

	TileMode $tile_mode - The tile mode flag.

Modifies an image so it will tile seamlessly if used as a tile (i.e.
drawn multiple times horizontally, vertically or both).

=over 4

=item *

IMLIB_TILE_HORIZONTAL - Drawn multiple times horizontally.

=item *

IMLIB_TILE_VERTICAL - Drawn multiple times vertically.

=item *

IMLIB_TILE_BOTH - Drawn multiple times horizontally and vertically.

=back

=head3 image_blur

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $image = $im.load_image("pictures/holidays.jpeg");
	$image.context_set();
	my Int $radius = 12;
	$im.image_blur($radius);
	... some operations ...
	$im.free_image();
	
Parameters:

	Int $radius = The radius (value between 0 and 128).

Blurs the current image. A radius value of 0 has no effect, 1 and above
determine the blur matrix radius that determine how much to blur the
image.

=head3 image_sharpen

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $image = $im.load_image("pictures/holidays.jpeg");
	$image.context_set();
	my Int $radius = 20;
	$im.image_sharpen($radius);
	... some operations ...
	$im.free_image();

Parameters:

	Int $radius = The radius (value between 0 and 128).

Sharpens the current image. The radius value affects how much to
sharpen by.

=head2 Fonts and text

Functions to handle the fonts and text that you use in the images.

=head3 load_font

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	$im.add_path_to_font_path("t/fonts");
	my Str $font = "comic";
	my Int $size = 36;
	my Imlib2::Font $corefont = $im.load_font($font, $size);
	$corefont.context_set();
	... some operations ...
	$im.free_font();

Parameters:

	Str $font - The font name without ttf extension.
	Int $size - The font size in pixels.

Returns:

	Imlib2::Font $corefont - A valid font, otherwise NULL if no font found.

Loads a truetype font from the first directory in the font path that
contains that font. For example. If there is a font file called blum.ttf
somewhere in the font path you might use "blum" for font name and 20 to
load a 20 pixel sized font of blum. If the font cannot be found NULL is
returned.

=head3 free_font

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	$im.add_path_to_font_path("/usr/share/fonts/corefonts");
	my Imlib2::Font $corefont = $im.load_font("comic", 36);
	$corefont.context_set();
	... some operations ...
	$im.free_font();

Removes the current font from any fallback chain it's in and frees it.

=head3 context_set

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	$im.add_path_to_font_path("/usr/share/fonts/corefonts");
	my $corefont = $im.load_font("comic", 36);
	$corefont.context_set();
	$im.free_font();

Parameters:

	Imlib2::Font $font - Current font. 

Sets the current font to use when rendering text. you should load the
font first with load_font().

=head3 text_draw

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $rawimage = $im.create_image(200, 200);
	$rawimage.context_set();
	$im.add_path_to_font_path("/usr/share/fonts/corefonts");
	my $corefont = $im.load_font("comic", 36);
	$corefont.context_set();
	my Int $x = 10;
	my Int $y = 10;
	my Str $text = "perl6";
	$im.text_draw($x, $y, $text);

	# text_draw but with return metrics.	
	my %returned_metrics;
	$im.text_draw(10, 10, "perl6", %returned_metrics);
	say "The width of the string: " ~ %returned_metrics{'width'};
	say "The height of the string: " ~ %returned_metrics{'height'};
	say "The horizontal offset: " ~ %returned_metrics{'horizontal_advance'};
	say "The vertical offset: " ~ %returned_metrics{'vertical_advance'};

	$im.free_font();
	$im.free_image();

Parameters:

	Int $x - The x coordinate of the top left corner.
	Int $y - The y coordinate of the top left corner.
	Str $text - The text string.
	Hash returned_metrics - Hash with returned metrics of the string drawn.

Draws the string text using the current font on the current image at the
(x, y) location (x, y denoting the top left corner of the font string).
If the hash metrics is passed also returns the width and height of the
string drawn, and horizontal_advance returns the number of pixels you
should advance horizontally to draw another string (useful if you are
drawing a line of text word by word) and vertical_advance does the same
for the vertical direction (i.e. drawing text line by line).

=over 4

=item *

%returned_metrics{'width'} - The width of the string.

=item *

%returned_metrics{'height'} - The height of the string.

=item *

%returned_metrics{'horizontal_advance'} - The horizontal offset.

=item *

%returned_metrics{'vertical_advance'} - The vertical offset.

=back

=head3 get_text_size

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	$im.add_path_to_font_path("/usr/share/fonts/corefonts");
	my $corefont = $im.load_font("comic", 36);
	$corefont.context_set();
	my Str $text = "perl6";
	my ($width, $height) = $im.get_text_size($text);
	say "The width of the string: " ~ $width;
	say "The height of the string: " ~ $height;
	$im.free_font();

Parameters:

	Str $text - The text string.

Returns:

	Int $width - The width of the text.
	Int $height - The height of the text.

Gets the width and height in pixels the text string would use up if
drawn with the current font.

=head3 get_text_advance

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	$im.add_path_to_font_path("/usr/share/fonts/corefonts");
	my $corefont = $im.load_font("comic", 36);
	$corefont.context_set();
	my Str $text = "perl6";
	my ($horizontal_advance, $vertical_advance) = $im.get_text_advance($text);
	say "The horizontal offset: " ~ $horizontal_advance;
	say "The vertical offset: " ~ $vertical_advance;
	$im.free_font();

Parameters:

	Str $text - The text string.

Returns:

	Int $horizontal_advance - The horizontal offset.
	Int $vertical_advance - The vertical offset.

Gets the advance horizontally and vertically in pixels the next text
string would need to be placed at for the current font. The advances
are not adjusted for rotation so you will have to translate the advances
(which are calculated as if the text was drawn horizontally from left to
right) depending on the text orientation.

=head3 get_text_inset

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	$im.add_path_to_font_path("/usr/share/fonts/corefonts");
	my $corefont = $im.load_font("comic", 36);
	$corefont.context_set();
	my Str $text = "perl6";
	my Int $inset = $im.get_text_inset($text);
	say "The inset value of: " ~ $inset;
	$im.free_font();

Parameters:

	Str $text - The text string.

Returns:

	Int $inset - The inset value of.

Returns the inset of the first character of text in using the current
font and returns that value in pixels.

=head3 get_font_ascent

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	$im.add_path_to_font_path("/usr/share/fonts/corefonts");
	my $corefont = $im.load_font("comic", 36);
	$corefont.context_set();
	my Int $ascent = $im.get_font_ascent();
	say "The font's ascent: " ~ $ascent;
	$im.free_font();

Returns:

	Int $ascent - The font's ascent.

Returns the current font's ascent value in pixels.

=head3 get_font_descent

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	$im.add_path_to_font_path("/usr/share/fonts/corefonts");
	my $corefont = $im.load_font("comic", 36);
	$corefont.context_set();
	my Int $descent = $im.get_font_descent();
	say "The font's descent: " ~ $descent;
	$im.free_font();

Returns:

	Int $descent - The font's descent.

Returns the current font's descent value in pixels.

=head3 get_maximum_font_ascent

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	$im.add_path_to_font_path("/usr/share/fonts/corefonts");
	my $corefont = $im.load_font("comic", 36);
	$corefont.context_set();
	my Int $max_ascent = $im.get_maximum_font_ascent();
	say "The font's maximum ascent: " ~ $max_ascent;
	$im.free_font();

Returns:

	Int $max_ascent - The font's maximum ascent.

Returns the current font's maximum ascent extent.

=head3 get_maximum_font_descent

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	$im.add_path_to_font_path("/usr/share/fonts/corefonts");
	my $corefont = $im.load_font("comic", 36);
	$corefont.context_set();
	my Int $max_descent = $im.get_maximum_font_descent();
	say "The font's maximum descent: " ~ $max_descent;
	$im.free_font();

Returns:

	Int $max_descent - The font's maximum descent.

Returns the current font's maximum descent extent.

=head3 add_path_to_font_path

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my Str $font_path = "/usr/share/fonts/corefonts";
	$im.add_path_to_font_path($font_path);
	my $corefont = $im.load_font("comic", 36);
	$corefont.context_set();
	... some operations ...
	$im.free_font();

Parameters:

	Str $font_path - A directory path.

Adds the directory path to the end of the current list of directories
to scan for fonts.

=head3 remove_path_from_font_path

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my Str $font_path = "/usr/share/fonts/corefonts";
	$im.add_path_to_font_path($font_path);
	my $corefont = $im.load_font("comic", 36);
	$corefont.context_set();
	... some operations ...
	$im.remove_path_from_font_path($font_path);
	$im.free_font();

Parameters:

	Str $font_path - A directory path.

Removes all directories in the font path that match path.

=head3 list_font_path

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	$im.add_path_to_font_path("fonts/localfonts");
	$im.add_path_to_font_path("/usr/share/fonts/corefonts");
	my @list = $im.list_font_path();
	say "Number of paths in the list: " ~ @list.elems;
	say "List of directories:\n" ~ @list.join("\n");

	# Number of paths in the list: 2
	# List of directories:
	# fonts/localfonts
	# /usr/share/fonts/corefonts
	... some operations ...

Returns:

	Array @list - A list of strings paths.

Returns a list of strings that are the directories in the font path.

=head3 list_fonts

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	$im.add_path_to_font_path("/usr/share/fonts/corefonts");
	my @list = $im.list_font();
	say "Number of fonts in the list: " ~ @list.elems;
	say "List of fonts:\n" ~ @list.join("\n");

	# Number of fonts in the list: 30
	# List of fonts:
	# comic
	# andalemo
	# arial
	# arialbd
	# arialbi 
	# ...

	... some operations ...

Returns:

	Array @list - A list of strings fonts.

Returns a list of fonts imlib2 can find in its font path.

=head3 set_font_cache_size

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my Int $bytes = 512 * 1024;
	$im.set_font_cache_size($bytes);
	... some operations ...

Parameters:

	Int $bytes - The font cache size in bytes.

Sets the font cache in bytes. Whenever you set the font cache size
Imlib2 will flush fonts from the cache until the memory used by fonts
is less than or equal to the font cache size. Setting the size to 0
effectively frees all speculatively cached fonts.

=head3 get_font_cache_size

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my Int $bytes = $im.get_font_cache_size();
	... some operations ...

Returns:

	Int $bytes - The font cache size in bytes.

Returns the font cache size in bytes.

=head3 flush_font_cache

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	$im.flush_font_cache();
	... some operations ...

Causes a flush of all speculatively cached fonts from the font cache.

=head2 Color modifiers

Imlib 2 also supports Color Modifier curves. You can pass any operation
through a color modifier table that can correct gamma, brightness and
contrast values of an image - as well as indepednantly being able to
determine the mapping tables of each R, G, B and A channel in an image.

=head3 create_color_modifier

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	# Create highlight color modifier
	my $cm = $im.create_color_modifier();
	$cm.context_set_color_modifier();
	$im.modify_color_modifier(brightness => 25);
	... some operations ...

Returns:

	Imlib2::ColorModifier $cm - Valid handle.

Creates a new empty color modifier and returns a valid handle on
success. NULL is returned on failure.

=head3 free_color_modifier

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	# Create highlight color modifier
	my $cm = $im.create_color_modifier();
	$cm.context_set_color_modifier();
	$im.modify_color_modifier(brightness => 25);
	... some operations ...
	$im.free_color_modifier();

Frees the current color modifier. 

=head3 modify_color_modifier

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $cm = $im.create_color_modifier();
	$cm.context_set_color_modifier();
	$im.modify_color_modifier(
		gamma      => -50,
		brightness => 25,
		contrast   => 95);
	... some operations ...

Parameters:

	Int gamma - Value of gamma.
	Int brightness - Value of brightness.
	Int contrast - Value of contrast.

Modifies the current color modifier by adjusting the gamma, brightness
and contrast values. The color modifier is modified not set, so calling
this repeatedly has cumulative effects. The values ​​of the parameters are
applied in sequence, i.e., In the example, first the gamma is applied,
then the brightness and finally the contrast. You can change the
sequence and can even repeat the parameters. Example: brightness => 25,
contrast => -26, brightness => 62. The range of values goes from -127 to
127. A gamma of 0 is normal linear, 127 brightens and -127 darkens etc.
Brightness values of 0 do not affect anything. -127 will make things
completely black and 127 will make things all white. Values in-between
vary brightness linearly. Contrast of 0 does nothing. -127 will merge to
gray, 127 will double contrast etc.

=head3 set_color_modifier_tables

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $cm = $im.create_color_modifier();
	$cm.context_set_color_modifier();
	# Initialize the array tables
	my (@red_table, @green_table, @blue_table, @alpha_table);
	loop (my $i = 0; $i <= 255; $i++) {
		@red_table[255-$i] = $i;
		@green_table[255-$i] = $i;
		@blue_table[255-$i] = $i;
		@alpha_table[$i] = 127;
	}
	$im.set_color_modifier_tables(
		@red_table,
		@green_table,
		@blue_table,
		@alpha_table);
	$im.apply_color_modifier();
	... some operations ...

Parameters:

	@red_table - An array of Int.
	@green_table - An array of Int.
	@blue_table - An array of Int.
	@alpha_table - An array of Int.

Explicitly copies the mapping tables from the table pointers passed into
this function into those of the current color modifier. Internally,
tables are 256 entry arrays of DATA8 which are a mapping of that channel
value to a new channel value. A normal mapping would be linear
(v[0] = 0, v[10] = 10, v[50] = 50, v[200] = 200, v[255] = 255).

=head3 get_color_modifier_tables

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $cm = $im.create_color_modifier();
	$cm.context_set_color_modifier();
	# Initialize the array tables
	my @red_table = ();
	@red_table[$_] = 0 for 0..255;
	my @alpha_table = my @blue_table = my @green_table = @red_table;
	$im.get_color_modifier_tables(
		@red_table,
		@green_table,
		@blue_table,
		@alpha_table);
	... some operations ...

Parameters:

	@red_table - An array of Int.
	@green_table - An array of Int.
	@blue_table - An array of Int.
	@alpha_table - An array of Int.

Internally, copies the table values from the current color modifier into
the pointers to mapping tables specified. They must have 256 entries and
be DATA8 format.

=head3 reset_color_modifier

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	# Create highlight color modifier
	my $cm = $im.create_color_modifier();
	$cm.context_set_color_modifier();
	$im.reset_color_modifier();
	$im.modify_color_modifier(gamma => 75);
	... some operations ...
	$im.free_color_modifier();

Resets the current color modifier to have linear mapping tables.

=head3 apply_color_modifier

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $cm = $im.create_color_modifier();
	$cm.context_set_color_modifier();
	$im.modify_color_modifier(brightness => 25);
	$im.apply_color_modifier(
		location => (20, 20),
		size     => (200, 200)
	);
	... some operations ...

Parameters:

	location - The top left Int x and Int y coordinates of the rectangle.
	size - Parcel with the Int width and the Int height of the rectangle.

Uses the current color modifier and modifies the current image using the
mapping tables in the current color modifier. If the parameters are
provided only modifies a selected rectangle in the current image,
otherwise applies to the entire image.

=head2 Drawing on images.

Functions for drawing points, lines and rectangles.

=head3 image_draw_pixel

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $image = $im.create_image(200, 200);
	$image.context_set();
	$im.context_set_color("#ff0000");
	my ($x, $y) = (10, 10);
	my $update = False;
	my Imlib2::Updates $updates = $im.image_draw_pixel($x, $y, $update);
	... some operations ...
	$im.free_image();

Parameters:

	Int $x - The x coordinate of the pixel. 
	Int $y - The y coordinate of the pixel.
	Bool $update - True if should returns an updates list object, False
	               if not. This parameter is optional.

Returns:

	Imlib2::Updates $updates - An object to handle the updates list.

Draws a pixel using the current color on the current image at ($x, $y)
coordinates. If the B<update> parameter is set to True it will also
return an update you can use for an updates list, otherwise it returns
NULL.

=head3 image_draw_line

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $image = $im.create_image(200, 200);
	$image.context_set();
	$im.context_set_color("#ff0000");
	my Imlib2::Updates $updates = $im.image_draw_line(
		start => (10, 20),
		end   => (180, 190),
		update => False);
	... some operations ...
	$im.free_image();

Parameters:

	start - Parcel with Int x and Int y coordinates of the first point.
	end - Parcel with Int x and Int y coordinates of the second point.
	Bool update - True if should returns an updates list object, False if not.

Returns:

	Imlib2::Updates $updates - An object to handle the updates list.

Draws a line using the current color on the current image from B<start>
coordinates (x1, y1) to B<end> coordinates (x2, y2). If the B<update> option
is set to True it will also return an update you can use for an updates
list, otherwise it returns NULL.

=head3 image_draw_rectangle

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $image = $im.create_image(200, 200);
	$image.context_set();
	$im.context_set_color("#00ff00");
	$im.image_draw_rectangle(
		location => (10, 10),
		size     => (100, 100),
		fill     => False,
		gradient => False,
		angle    => 0.0,
		hsva     => False);
	... some operations ...
	$im.free_image();

Parameters:

	location - The top left Int x and Int y coordinates of the rectangle.
	size - Parcel with the Int width and the Int height of the rectangle.
	Bool fill - True if the rectangle should be filled, False if outlined.
	Bool gradient - True if the rectangle should be filled with a color
	                gradient, False if normal color.
	Rat angle - Angle of gradient.
	Bool hsva - The hsva option (True or False)

Draws the outline of a rectangle on the current image at the ($x, $y)
coordinates with a size of $width and $height pixels, using the current
color. Draws a filled rectangle on the current image if the fill option
is set to True.
If the fill and gradient option is set to True fills a rectangle of
width $width and height $height at the ($x, $y) location specified in
the current image with a linear gradient of the current color range at
an angle of angle degrees with 0 degrees being vertical from top to
bottom going clockwise from there. If the hsva option is set to True a
linear gradient in HSVA color space of the current color range is used.

=head2 Polygon

Functions to build and handle polygons.

=head3 polygon_new

Usage:

	use Imlib2;
	
	my $im = Imlib2.new();
	my $rawimage = $im.create_image(200, 200);
	$rawimage.context_set();
	my $polygon = $im.polygon_new();
	... some operations ...
	$polygon.free();
	$im.free_image();

Returns:

	Imlib2::Polygon $polygon - Polygon object.

Returns a new polygon object with no points set.

=head3 free

Usage:

	use Imlib2;
	
	my $im = Imlib2.new();
	my $rawimage = $im.create_image(200, 200);
	$rawimage.context_set();
	my $polygon = $im.polygon_new();
	... some operations ...
	$polygon.free();
	$im.free_image();

Frees a polygon object.

=head3 add_point

Usage:

	use Imlib2;
	
	my $im = Imlib2.new();
	my $rawimage = $im.create_image(200, 200);
	$rawimage.context_set();
	my $polygon = $im.polygon_new();
	my Int $x = 1;
	my Int $y = 1;
	$polygon.add_point($x, $y);
	$polygon.add_point($x+3, $y);
	$polygon.add_point($x+3, $y+2);
	$polygon.add_point($x+1, $y+3);
	... some operations ...
	$polygon.free();
	$im.free_image();

Parameters:

	Int $x - The x coordinate.
	Int $y - The y coordinate.

Adds the point (x, y) to the polygon $polygon. The point will be added
to the end of the polygon's internal point list. The points are drawn
in order, from the first to the last.

=head3 contains_point

Usage:

	use Imlib2;
	
	my $im = Imlib2.new();
	my $rawimage = $im.create_image(200, 200);
	$rawimage.context_set();
	my $polygon = $im.polygon_new();
	my Int $x = 2;
	my Int $y = 4;
	$polygon.add_point($x, $y);
	my Bool $test = $polygon.contains_point($x, $y);
	... some operations ...
	$polygon.free();
	$im.free_image();

Parameters:

	Int $x - The x coordinate.
	Int $y - The y coordinate.

Returns:

	my Bool $test - True if the point ($x, $y) is within the area,
	                otherwise False.

Returns True if the point (x, y) is within the area defined by the
polygon poly. Otherwise returns False.

=head3 get_bounds

Usage:

	use Imlib2;
	
	my $im = Imlib2.new();
	my $polygon = $im.polygon_new();
	my @points = (
		 30,  30, # top left corner
		180,  10, # top right corner
		180, 180, # bottom right corner
		 60, 190  # bottom left corner
	);
	for @points -> Int $x, Int $y {
		$polygon.add_point($x, $y);
	}
	my ($px1, $py1, $px2, $py2) = $polygon.get_bounds();
	say "X coordinate of the upper left corner: " ~ $px1;
	say "Y coordinate of the upper left corner: " ~ $py1;
	say "X coordinate of the lower right corner: " ~ $px2;
	say "Y coordinate of the lower right corner: " ~ $py2;
	$polygon.free();

Returns:

	Int $px1 - X coordinate of the upper left corner.
	Int $py1 - Y coordinate of the upper left corner.
	Int $px2 - X coordinate of the lower right corner.
	Int $py2 - Y coordinate of the lower right corner.

Calculates the bounding area of the polygon poly. ($px1, $py1) defines
the upper left corner of the bounding box and ($px2, $py2) defines it's
lower right corner.

=head3 image_draw_polygon

Usage:

	use Imlib2;
	
	my $im = Imlib2.new();
	my $rawimage = $im.create_image(200, 200);
	$rawimage.context_set();
	my $polygon = $im.polygon_new();
	my @points = (
		 30,  30, # top left corner
		180,  10, # top right corner
		180, 180, # bottom right corner
		 60, 190  # bottom left corner
	);
	for @points -> Int $x, Int $y {
		$polygon.add_point($x, $y);
	}
	$im.context_set_color(0x000000ff);
	$im.image_draw_polygon(
		$polygon,
		closed => True,
		fill   => False );
	$polygon.free();
	$im.free_image();

Parameters:

	Imlib2::Polygon $polygon - A polygon.
	Bool fill - True if the polygon should be filled, False if outlined.
	Bool closed - Closed polygon flag (True or False).

Draws the polygon $polygon onto the current context image if fill option
is set to False otherwise fills the area defined by the polygon $polygon
if the fill is set to True. Points which have been added to the polygon
are drawn in sequence, first to last. The final point will be joined
with the first point if closed is True. Fills the area defined by the
polygon $polygon on the current context image with the current context
color.

=head2 Ellipse/Circumference

Functions to handle ellipses and circumferences.

=head3 image_draw_ellipse

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $image = $im.create_image(200, 200);
	$image.context_set();
	$im.context_set_color(0x000000ff);
	my Int $xcenter = 100;
	my Int $ycenter = 100;
	my Int $hamplitude = 50;
	my Int $vamplitude = 50;
	my Bool $fill = False;
	$im.image_draw_ellipse(
		center    => ($xcenter, $ycenter),
		amplitude => ($hamplitude, $vamplitude)
		fill      => $fill);
	... some operations ...
	$im.free_image();
	
Parameters:

	Int $xcenter - The X coordinate of the center of the ellipse.
	Int $ycenter - The Y coordinate of the center of the ellipse.
	Int $hamplitude - The horizontal amplitude of the ellipse.
	Int $vamplitude - The vertical amplitude of the ellipse.
	Bool $fill - True if the ellipse should be filled, False if outlined.

Draws the outline of a ellipse on the current context image using the
current context color. If the $fill option is set to True fills an
ellipse on the current context image. The ellipse is defined as
(x-xcenter)^2/hamplitude^2 + (y-ycenter)^2/vamplitude^2 = 1. This means
that the point (xcenter, ycenter) marks the center of the ellipse,
a defines the horizontal amplitude of the ellipse, and vamplitude
defines the vertical amplitude.

=head3 image_draw_circumference

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $image = $im.create_image(200, 200);
	$image.context_set();
	$im.context_set_color(0x000000ff);
	my Int $xcenter = 100;
	my Int $ycenter = 100;
	my Int $radius = 50;
	my Bool $fill = False;
	$im.image_draw_circumference(
		center => ($xcenter, $ycenter),
		radius => $radius
		fill   => $fill);
	... some operations ...
	$im.free_image();
	
Parameters:

	Int $xcenter - The X coordinate of the center of the circumference.
	Int $ycenter - The Y coordinate of the center of the circumference.
	Int $radius - The radius of the circumference.
	Bool $fill - True if the circumference should be filled, False if outlined.

Draws the outline of a circumference on the current image at the center
(xcenter, ycenter) coordinates with a radius, using the current color.
If the $fill option is set to True fills an circumference on the current
context image.

=head2 Color Ranges

Functions to build color gradients.

=head3 create_color_range

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my Imlib2::ColorRange $color_range = $im.create_color_range();
	$color_range.context_set();
	... some operations ...
	$im.free_color_range();

Returns:

	Imlib2::ColorRange $color_range - Valid handle. 

Creates a new empty color range and returns a valid handle to that
color range.
	
Sets the current color range to use for rendering gradients.

=head3 free_color_range

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $color_range = $im.create_color_range();
	$color_range.context_set();
	... some operations ...
	$im.free_color_range();

Frees the current color range.

=head3 context_set

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $color_range = $im.create_color_range();
	$color_range.context_set();
	... some operations ...
	$im.free_color_range();

Parameters:

	Imlib2::ColorRange $color_range - Color range.

=head3 add_color_to_color_range

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $color_range = $im.create_color_range();
	$color_range.context_set();
	my Int $distance_away = 0;
	$im.add_color_to_color_range($distance_away);
	... some operations ...
	$im.free_color_range();

Parameters:

	Int $distance_away - Distance from the previous color.

Adds the current color to the current color range at a $distance_away
distance from the previous color in the range (if it's the first color
in the range this is irrelevant).

=head2 Saving.

Functions to save the current image.

=head3 save_image

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $image = $im.create_image(100, 200);
	$image.context_set();
	$im.image_set_format("png");
	... some operations ...
	my Str $filename = "test.png";
	$im.save_image($filename);
	$im.free_image();

	# save image with returned error.
	use Imlib2;
	my $im = Imlib2.new();
	my $image = $im.create_image(100, 200);
	$image.context_set();
	$im.image_set_format("png");
	... some operations ...
	my Str $filename = "test.png";
	my LoadError $error_return;
	$im.save_image($filename, $error_return);
	say "No error..." if $error_return == IMLIB_LOAD_ERROR_NONE;
	$im.free_image();

Parameters:

	Str $filename - Image file.
	LoadError $error_return - The returned error.

Saves the current image in the format specified by the current image's
format settings to the filename $filename.
If the $error_return is passed as argument the $error_return will be
set to an error value if the save fails.

=head2 Rotation/Skewing

Functions to rotate/swew images.

=head3 create_rotated_image

Usage:

	use Imlib2;
	my $im = Imlib2.new();
	my $loaded_image = $im.load_image("pictures/holidays.jpeg");
	$loaded_image.context_set();
	my Rat $angle = -45.0;
	my Imlib2::Image $rotated_image = $im.create_rotated_image($angle);
	$rotated_image.context_set();
	... some operations ...
	$im.free_image(); # frees the rotated image
	$loaded_image.context_set();
	$im.free_image(); # frees the loaded image

Parameters:

	Rat $angle - An angle in degrees (-360 to 360).

Returns:

	Imlib2::Image $rotated_image - A valid image, otherwise NULL.

Creates an new copy of the current image, but rotated by angle degrees.
On success it returns a valid image handle, otherwise NULL.

=head2 Imlib2::Border

Structure to store and handle the values of the border.

=head3 new

Usage:

	use Imlib2;
	my $structure = Imlib2::Border.new(
		left   => 10,
		right  => 10,
		top    => 10,
		bottom => 10);
	... some operations ...

Parameters:

	left - Left side of the border in pixels.
	right - Right side of the border in pixels.
	top - Top side of the border in pixels.
	bottom - Bottom side of the border in pixels.

Returns:

	Imlib2::Border $structure - Structure to store the values ​​of the border.

Returns a new structure to store the values of the border of the
current context image. The parameters are optional. By default the value
of each side of the border is equal to zero.

=head3 init

Usage:

	use Imlib2;
	my $structure = Imlib2::Border.new(
		left   => 10,
		right  => 10,
		top    => 10,
		bottom => 10);
	my $border = $structure.init();
	... some operations ...

Returns:

	OpaquePointer $border - Returns a C pointer.

Store the values of the border in C structure and returns a pointer
to this.

=head3 put

Usage:

	use Imlib2;
	my $structure = Imlib2::Border.new();
	my $border = $structure.init();
	$structure.left = 10;
	$structure.right = 10;
	$structure.top = 10;
	$structure.bottom = 10;
	$structure.put($border);
	... some operations ...

Parameters:

	OpaquePointer $border - C pointer.

Only store the values of the border in C structure.

=head3 get

Usage:

	use Imlib2;
	my $structure = Imlib2::Border.new(
		left   => 10,
		right  => 10,
		top    => 10,
		bottom => 10);
	my $border = $structure.init();
	$structure.get($border);
	say "Left: " ~ $structure.left;
	say "Right: " ~ $structure.right;
	say "Top: " ~ $structure.top;
	say "Bottom: " ~ $structure.bottom;
	... some operations ...

Parameters:

	OpaquePointer $border - C pointer.

Get the stored values of the border from the C structure and update the
attributes left, right, top and bottom.

=head1 AUTHOR

Henrique Dias - L<mrhdias@mail.com>

=head1 SEE ALSO

=over 4

=item *

Imlib2 Library Documentation L<http://docs.enlightenment.org/api/imlib2/html/>

=item *

Imlib2 Source Repository L<http://sourceforge.net/projects/enlightenment/files/imlib2-src/>

=back

=head1 LICENSE

This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

